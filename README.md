# Algorithms
This repo contains all solved tasks from Algorithm course in Akvelon

## Homework 1

### Searching 
Даны два массива. Для каждого элемента из второго массива найти сколько элементов из 1-го массива строго меньше

Решение: сортируем первый массив, бежим по второму и двоичный поиск

### PolandAndGame
Двое играют в слова. Даны их словари. Выяснить, кто выиграет

Решение: заводим два Dictionary, в цикле имитируем ходы игроков. Выбираем всегда то слово, которое есть у противника, чтобы заблокировать ему это слово

### MillionaireCity
Есть город Томск с координатами (0, 0) и заданным числом жителей. Даны также n других городов с координатами и числом жителей. Определить минимальный радиус для расширения города Томска до миллиона жителей.

Решение: 
```
// Сортируем населенные пункты по радиусу. Радиус вычислили при заполнении данных
Array.Sort(villages);

// Вычисляем бегущую сумму людей
villages[0].PeopleSum = villages[0].PeopleAmount;
for (int i = 0; i < villages.Length - 1; i++)
{
	villages[i + 1].PeopleSum = villages[i + 1].PeopleAmount + villages[i].PeopleSum;
}

Console.WriteLine(BinarySearch(villages, 1000000 - s));
```
### IvanAndLantern
Даны координаты фонарей, выяснить минимальный радиус освещения фонаря, чтобы они осветили всю улицу длины L. 

Решение: просто находим максимальное расстояние между фонарями. Не забыть учесть случаи, когда по краям улицы нет фонарей. В этих случаях нужно считать длину от фонаря до края улицы.

```
Array.Sort(a);

if (a[0] != 0)
	d = a[0];
if (a[n - 1] != l)
	d = Max((int) d, l - a[n - 1]);

for (int i = 0; i < n - 1; i++)
{
	double radius = (a[i + 1] - a[i]) / 2;
	if(radius > d)
	{
		d = radius;
	}
}
Console.WriteLine(d);
```

### InterestingDrink
Дан массив цен на напиток для разных магазинов. Дан массив, где указано количество денег на каждый день. Определить для каждого дня, в скольки магазинах ему хватит денег на напиток

Решение: 
```
Array.Sort(x);

for (int i = 0; i < q; i++)
{
	m[i] = BinarySearch(x, int.Parse(Console.ReadLine()) );
}

for (int i = 0; i < q; i++)
{
	Console.WriteLine(m[i]);
}
```

### EvgeniiAndPlaylist
Дана коллекция песен. Указано время песни и сколько раз Женя её слушал. Далее дан массив отметок, понравившихся моментов. Найти номер песни, для каждой отметки

Решение: считаем бегущую сумму времени для каждой песни. Т.е. сколько всего времени прошло до того, как песня заиграла. Потом бежим по меткам и двоичным поиском находим песни

### ChatsOrder
Дан список людей, которые отсылали сообщения в чат, в порядке отсылки. Т.е. первый списке тот, кто писал давно. Нужно вывести чаты в таком порядке, чтобы наверху были более новые сообщения.

Решение: идем снизу вверх, и не выводим те, которые уже были. Для этого после вывода кладем в словарь. Перед выводом проверяем, нет ли этого человека в словаре
```
string line1 = Console.ReadLine();
int n = int.Parse(line1);

string[] names = new string[n];
for (int i = 0; i < n; i++)
{
	names[i] = Console.ReadLine();
}

Dictionary<string, string> namesSet = new Dictionary<string, string>(n);

for (int i = names.Length - 1; i >= 0; i--)
{
	if (!namesSet.ContainsKey(names[i]))
	{
		Console.WriteLine(names[i]);
		namesSet.Add(names[i], null);
	}                    
}
```


